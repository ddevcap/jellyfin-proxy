package middleware

import (
	"net/http"
	"sync"
	"time"

	"github.com/ddevcap/jellyfin-proxy/config"
	"github.com/gin-gonic/gin"
)

// ipEntry tracks failed login attempts for a single IP.
type ipEntry struct {
	attempts    int
	windowEnd   time.Time // when the current sliding window expires
	bannedUntil time.Time
}

// loginLimiter is an in-memory rate limiter for the login endpoint.
type loginLimiter struct {
	mu      sync.Mutex
	entries map[string]*ipEntry
	cfg     config.Config
	stop    chan struct{}
}

func newLoginLimiter(cfg config.Config) *loginLimiter {
	l := &loginLimiter{
		entries: make(map[string]*ipEntry),
		cfg:     cfg,
		stop:    make(chan struct{}),
	}
	// Periodically clean up stale entries to prevent unbounded memory growth.
	go func() {
		ticker := time.NewTicker(5 * time.Minute)
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				l.cleanup()
			case <-l.stop:
				return
			}
		}
	}()
	return l
}

// cleanup removes entries whose ban and window have both expired.
func (l *loginLimiter) cleanup() {
	now := time.Now()
	l.mu.Lock()
	defer l.mu.Unlock()
	for ip, e := range l.entries {
		if now.After(e.bannedUntil) && now.After(e.windowEnd) {
			delete(l.entries, ip)
		}
	}
}

// allow returns true if the IP is permitted to attempt a login.
// Call recordFailure after a failed attempt.
func (l *loginLimiter) allow(ip string) bool {
	l.mu.Lock()
	defer l.mu.Unlock()
	e, ok := l.entries[ip]
	if !ok {
		return true
	}
	if time.Now().Before(e.bannedUntil) {
		return false
	}
	return true
}

// recordFailure increments the failure count for an IP and bans it if
// the threshold is exceeded within the window.
func (l *loginLimiter) recordFailure(ip string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	now := time.Now()
	e, ok := l.entries[ip]
	if !ok || now.After(e.windowEnd) {
		// Start a fresh window.
		l.entries[ip] = &ipEntry{
			attempts:  1,
			windowEnd: now.Add(l.cfg.LoginWindow),
		}
		return
	}
	e.attempts++
	if e.attempts >= l.cfg.LoginMaxAttempts {
		e.bannedUntil = now.Add(l.cfg.LoginBanDuration)
	}
}

// recordSuccess resets the failure count for an IP after a successful login.
func (l *loginLimiter) recordSuccess(ip string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	delete(l.entries, ip)
}

// LoginRateLimiter returns a middleware + a recordFailure/recordSuccess pair
// so the auth handler can signal outcomes.
// Returns the middleware, two callbacks: onFailure(ip), onSuccess(ip), and a
// stop function to clean up the background goroutine on shutdown.
func LoginRateLimiter(cfg config.Config) (gin.HandlerFunc, func(string), func(string), func()) {
	limiter := newLoginLimiter(cfg)

	mw := func(c *gin.Context) {
		if cfg.LoginMaxAttempts <= 0 {
			c.Next()
			return
		}
		ip := ClientIP(c)
		if !limiter.allow(ip) {
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"error": "Too many failed login attempts. Please try again later.",
			})
			return
		}
		c.Next()
	}

	stop := func() { close(limiter.stop) }

	return mw, limiter.recordFailure, limiter.recordSuccess, stop
}

// ClientIP extracts the client IP using Gin's built-in ClientIP method,
// which honours the engine's trusted-proxy configuration and safely handles
// X-Forwarded-For chains. Falls back to RemoteAddr when no proxy is trusted.
func ClientIP(c *gin.Context) string {
	return c.ClientIP()
}
